import re, sys, subprocess, json, os
from math import log, sqrt
from collections import OrderedDict as ordd

def count_oe(xy, x, y, N, ws):
    return [xy, x - xy, y - xy, N - x - y + xy], [x * y / N * ws, x * ((N - y) / N) ** ws, y * ((N - x) / N) ** ws, (1 - (x / N + y / N)) * N]

def mi(xy, x, y, N, ws = 1):
    return log(xy / (x * y / N * ws) , 2)

def mi3(xy, x, y, N, ws = 1):
    return log(xy ** 3/ (x * y / N * ws) , 2)

def frequency(xy, x, y, N, ws = 1):
    return xy

def ll(xy, x, y, N, ws = 1):
    o, e = count_oe(xy, x, y, N, ws)
    l = 0
    for i in [1,2]:
        for j in [1,2]:
            ind = (j - 1) + (i - 1) * 2
            x = o[ind] * log(o[ind] / float(e[ind]))
            l += x
    return 2 * l

def t_score(xy, x, y, N, ws = 1):
    o, e = count_oe(xy, x, y, N, ws)
    return(o[0] - e[0]) / sqrt(o[0])

def z_score(xy, x, y, N, ws = 1):
    o, e = count_oe(xy, x, y, N, ws)
    return(o[0] - e[0]) / sqrt(e[0])

def dice(xy, x, y, N, ws = 1):
    o, e = count_oe(xy, x, y, N, ws)
    return 2 * o[0] / float(x + y)

def loadFreq(path, cs):
    freq = {}
    count = 0.
    with open(path) as fin:
        for line in fin:
            fq, word = line.strip().split()
            if cs:
                word = word.lower()
            if word in freq:
                freq[word] += int(fq)
            else:
                freq[word] = int(fq)
            count += int(fq)

    return freq, count


# def old_code(params, settings):

def process(cwb_output, params, settings):
    """
    Takes cwb_output (the string output generated by CWB) and processes it
    to turn into a proper data format suitable for consumption in a Django template
    """

    AMs = (('llr', ll, '%.2f'), ('mi', mi, '%.2f'), ('t-score', t_score, '%.2f'), ('z-score', z_score, '%.2f'), ('dice', dice, '%.4f'), ('mi3', mi3, '%.2f'), ('frequency', frequency, '%d'))

    freqDir = 'resources'
    if 'sort' in params:
        sort = [el[0] for el in AMs].index(params['sort']) + 1
    else:
        sort = 1

    query = params['query']
    countBy = settings['countBy']
    threshold = settings['threshold']
    chosenAms = [am for am in AMs if am[0] in settings['ams']]
    leftContext = settings['leftContextSize']
    rightContext = settings['rightContextSize']

    module_dir = os.path.dirname(__file__)
    freqPath = os.path.join(module_dir, 'freq_birm_eng_word.txt')

    if '%c' in params['query']:
        cs = True
    else:
        cs = False
    freq, N = loadFreq(freqPath, cs)

    columns = ''
    for i in range(len(chosenAms)):
        columns += '<th class="sortable">%s</th>\n' % (chosenAms[i][0])


    command = [params['cwbdir'], '-r', params['registry'], '%s; set LeftContext %d words; set RightContext %d words; show -cpos; show +lemma; %s;' % (params['corpusname'], leftContext, rightContext, query)]

    # results2 = subprocess.check_output(command, universal_newlines=True)

    results = str(cwb_output)

    collocates = {}
    node = ''
    for line in results.splitlines():
        words = [el.rsplit('/', 1)[countBy == 'lemma' and 1 or 0] for el in line.strip().split()]

        if not node:
            node = str(words[leftContext])
            if countBy == 'lemma':
                node = node[:-1]
            else:
                node = node[1:]
        try:
            del words[int(leftContext)]
        except IndexError:
            continue
        words = list(set(words))
        for word in words:
            if not word:
                continue
            if word.lower() == 'that/in':
                word = 'that'
            if cs:
                word = word.lower()
            if word in collocates:
                collocates[word] += 1
            else:
                collocates[word] = 1
    if cs:
        node = node.lower()
    fa = freq[node]
    collocations = []


    for collocate, fab in [coll for coll in collocates.items() if coll[1] >= threshold]:
        if cs:
            collocate = collocate.lower()
        try:
            fb = freq[collocate]
        except KeyError:
            continue
        tmp = [collocate]
        if fa < fab or fb < fab:
            continue
        for amName, amFoo, format in chosenAms:
            try:
                tmp.append(amFoo(fab, fa, fb, N))
            except:
                sys.stderr.write('err: %s %f, %f, %f, %d' % (amName, fab, fa, fb, N))
                tmp.append(0)
        collocations.append(tmp)
    collocations.sort(key = lambda x: x[sort], reverse = True)


    queryRes = ''
    if leftContext > 2:
        queryRes = '%s[]{0,%d}%s' % ('%s', leftContext - 1, params['query'].replace('%', '%%'))
    elif leftContext:
        queryRes = '%s[]?%s' % ('%s', params['query'].replace('%', '%%'))
    else:
        queryRes = '%s'
    if rightContext and leftContext:
        queryRes += ' | '
    if rightContext > 2:
        queryRes += '%s[]{0,%d}%s' % (params['query'].replace('%', '%%'), rightContext - 1, '%s')
    elif rightContext:
        queryRes += '%s[]?%s' % (params['query'].replace('%', '%%'), '%s')
    else:
        queryRes += '%s'

    GET_dict = {'query':  queryRes, 'langs': '-'.join(params['langs']), 'primlang': params['primlang']}
    sys.stderr.write('qR:' + queryRes + '\n\n')


    collocation_data = []

    for ind, coll in enumerate(collocations):
        word = str(coll[0])
        ams = {
            'name': [chosenAms[i][0] for i in range(len(chosenAms))],
            'output': [chosenAms[i][2] % coll[i + 1] for i in range(len(chosenAms))]
        }
        get_query = []
        for name, val in GET_dict.items():
            if name == 'query':
                try:
                    get_query.append('query=' + val % (leftContext and '[%s="%s"%%c]' % (countBy, word) or '', rightContext and '[%s="%s"%%c]' % (countBy, word) or ''))
                except:
                    sys.stderr.write(val + ' ! ' + str(type(val)) + '\n')
                    raise
            else:
                get_query.append(name + '=' + val)
        
        # collocation_data.append('\t'.join([word] + ams))
        
        # collocation_data.append({
        #     'word': word,
        #     'ams': chosenAms
        # })

        # Build a row to show in output table. Example of completed row:
        # {'word': 'the', 'llr': '33850.44', 't-score': '85.22', 'dice': '0.0043', 'mi3': '29.48'}
        row = {'word': word}
        # Append each chosen AM to the row dict
        for i, am in enumerate(chosenAms):
            row[am[0].replace('-', '')] = am[2] % coll[i+1]  # e.g. 'llr': 33850.44
        collocation_data.append(row)

    return collocation_data, len(collocations)
